

## 2.3 多线程

> 作者：zlz
>
> **介绍:** 并发专题 
### 什么是JMM模型
**java内存模型（Java Memory Model简称JMM）是一种抽象的概念**，并不是真实存在。他是一种规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）
的访问方式。JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，
主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，
操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的
工作内存，线程间的通信(传值)必须通过主内存来完成。

JMM不同于JVM，JMM是围绕**原子性，有序性、可见性**展开。

![JMM模型](../resource/images/并发/jmm模型.png ':size=60%')

#### JMM八大原子操作

- **lock（加锁）**：作用于主内存的变量，将一个变量标记成一条线程独占状态；
- **read（读取）**：作用于主内存的变量，将主内存变量读取到工作内存中，以便随后的load操作；
- **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量放入工作内存的变量副本中；
- **use（使用）**：作用于工作内存的变量，将工作内存中的变量交给CPU修改；；
- **assign（赋值）**：作用于工作内存变量，把它从CPU执行后的结果赋值给工作内存中的变量；；
- **store（存储）**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作；
- **write（写入）**：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中；
- **unlock（解锁）**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；

![八大原子操作](../resource/images/并发/八大原子操作.png ':size=60%')

#### 并发中原子性、有序性、可见性问题

**原子性**

原子性代表一单操作开始就不可被中断，在并发中不被其他线程进行操作；

对基本数据类型的变量的读取和赋值操作是原子性操作有点要注意的是，对于32位系统来说，long类型数据与double类型数据都是非原子性的，
而对于其他基本数据类型（byte,short,int,float,boolean,char）是原子性的，也就是说有两个线程同时对long或double进行读写操作，无法保证数据安全性。

**有序性**

有序性是指对线程中执行程序的先后顺序，我们一般正常的认为代码都是从上往下执行的，然而其实不完全如此，在代码执行过程中可能会出现指令重排的现象，指令重排与
原指令顺序不一致，但是最终结果是一致的。

### Reference

- 《深入理解 Java 虚拟机》


