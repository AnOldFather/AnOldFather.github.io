


> 作者：ZlZ。
>
> **介绍:** 此篇幅将简述垃圾收集器底层原理，干货满满

## 4.1 概述
说起垃圾收集器，大部分人都把这项技术当作Java语言的伴生产物，实际上，GC的历史远远比Java久远，1960年诞生与MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的的语言。当ListP
还在胚胎的时候，人们就在思考GC需要完成的三个步骤
- 哪些内存对象需要回收？
- 什么时候回收？
- 如何回收？

经过半个世纪的发展，目前内存的动态与内存回收技术已经十分成熟，一起看起来都进入了“自动化”的时代，那为什么我们还需要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出，内存泄漏问题时
，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

## 4.2 对象已经死了吗
在java堆中几乎存储着java大部分的对象，我们回收对象时，如何判断对象是否“存活”或者“死亡”；

### 4.2.1 引用计数算法

给对象添加一个引用计数器，**如果有其他新增对象引用，计数器+1，有其他对象删除引用，计数器-1，** 这样就很容易将死亡的对象区分出来，只要找出计数器=0的对象就好。
但如果出现了循环引用呢？A对象引用B，B对象引用着A，此时按照引用技术算法，双方对象计数器都=1，永远无法成为死亡对象；

### 4.2.2 可达性分析算法

在现在主流的虚拟机中，都是通过可达性分析算法找出死亡对象，简单说明：**可达性分析算法，从“GCRoot”作为起点开始，对其所有引用的对象进行扫描，扫描到该对象，再对该对象的引用扫描，
直到对象没有任何引用对象为止，扫描结束**（具体原理：三色标记）。

![标记复制算法](../resource/images/GC/可达性分析算法.jpg ':size=600x300')

**在java中，可作为GCRoot的对象有以下几种**
- 虚拟机栈中的引用对象；
- 方法区中类静态属性应用变量；
- 方法区中常量引用对象；
— 本地方法栈中JNI（即一般说的Natice方法）引用对象；

### 4.2.3 引用关系
无论是“引用计数算法”还是“可达性分析算法”，判定对象是否存活都跟“引用”有关。在JDK1.2之前，Java中的引用对象的定义很传统；如果reference类型的数据中存储的数值代表的是另一块内存的
起始地址，就称为这块内存代表着一个引用，这样定义很纯粹；

在JDK1.2之后，Java对引用的概念进行了区分：**强引用，软引用，弱引用，虚引用；**

#### 4.2.3.1 强引用
强引用就是程序代码之间普遍存在的。类似`Object o = new Object()`的存在，垃圾回收器永远都不会删除的对象；
#### 4.2.3.1 软引用
软引用是指用来描述一些还有用但是没有必要的对象。对于软引用关联着的对象，在系统将要发生的内存溢出异常之前，会将这些对象纳入回收范围内进行二次回收，防止内存溢出，如果这次回收还是没有足够的
内存空间，将抛出内存溢出的异常。JDK1.2之后，提供了`SoftReference`类来实现软引用；
#### 4.2.3.1 弱引用
弱引用是指用来描述那些非必要的对象的，但是他的强度比软应用更弱一些，被弱引用关联的对象，在GC发生之前，不管内存充不充足都会别垃圾处理器收集器回收掉；
JDK1.2之后，提供了`WeakReference`类来实现软引用；
#### 4.2.3.1 虚引用
虚引用也成为幽灵应用，它是一种最弱的应用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取一个真实的对象实例。为一个对象设置虚引用关联唯一目的
就是能够在这个对象被收集器回收时接受一个系统通知。JDK1.2之后，提供了`PhantomReference`类来实现软引用；


## 4.2 回收算法
我们都知道java对象是在堆上分配的（不考虑逃逸分析），通过垃圾回收器将不再使用的对象进行垃圾回收从而防止内存溢出。根据对象的不同生命周期将堆分成了两块年轻代和老年代，这样我们就可以根据每个
年代的特点选择合适的算法；
### 4.3.1 标记-复制算法
![标记复制算法](../resource/images/GC/标记复制算法.jpeg ':size=600x300')

标记复制算法，将内存分为了两半，一半存储对象，另一半空闲，进行回收时将存活对象打上标记，然后复制到另一半的内存中，将原来的内存进行回收；
**回收效率高，但因为内存分为了两半，浪费了一半的内存空间**

### 4.3.2 标记-清除算法
![标记清除算法](../resource/images/GC/标记清除算法.jpeg ':size=600x300')

标记清楚算法，回收时将内存中存活的对象打上GC标记，将未标记的内存行进行回收；**如果回收对象太多，效率不会太高，而且会产生大量不连续的空间碎片；**

### 4.3.2 标记-整理算法

![标记整理算法](../resource/images/GC/标记整理算法.jpeg ':size=600x300')

标记整理算法，回收时将存活的对象打上标记，虽然过程和标记-清除算法一样，但是后续回收不是直接回收对象，而是让对象向一端移动，然后清理掉边界以外的内存；

**新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上**

## 4.3 垃圾收集器

### 4.3.1 
