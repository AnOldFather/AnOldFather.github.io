


> 作者：ZlZ。
>
> **介绍:** 此篇幅将简述垃圾收集器底层原理，干货满满

## 4.1 概述
说起垃圾收集器，大部分人都把这项技术当作Java语言的伴生产物，实际上，GC的历史远远比Java久远，1960年诞生与MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的的语言。当ListP
还在胚胎的时候，人们就在思考GC需要完成的三个步骤
- 哪些内存对象需要回收？
- 什么时候回收？
- 如何回收？

经过半个世纪的发展，目前内存的动态与内存回收技术已经十分成熟，一起看起来都进入了“自动化”的时代，那为什么我们还需要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出，内存泄漏问题时
，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

## 4.2 对象已经死了吗
在java堆中几乎存储着java大部分的对象，我们回收对象时，如何判断对象是否“存活”或者“死亡”；

### 4.2.1 引用计数算法

给对象添加一个引用计数器，**如果有其他新增对象引用，计数器+1，有其他对象删除引用，计数器-1，** 这样就很容易将死亡的对象区分出来，只要找出计数器=0的对象就好。
但如果出现了循环引用呢？A对象引用B，B对象引用着A，此时按照引用技术算法，双方对象计数器都=1，永远无法成为死亡对象；

### 4.2.2 可达性分析算法

在现在主流的虚拟机中，都是通过可达性分析算法找出死亡对象，简单说明：**可达性分析算法，从“GCRoot”作为起点开始，对其所有引用的对象进行扫描，扫描到该对象，再对该对象的引用扫描，
直到对象没有任何引用对象为止，扫描结束。**（具体过程可见-三色标记）。

![标记复制算法](../resource/images/GC/可达性分析算法.jpg ':size=600x300')

**在java中，可作为GCRoot的对象有以下几种**
- 虚拟机栈中的引用对象；
- 方法区中类静态属性应用变量；
- 方法区中常量引用对象；
— 本地方法栈中JNI（即一般说的Natice方法）引用对象；

### 4.2.3 引用关系
无论是“引用计数算法”还是“可达性分析算法”，判定对象是否存活都跟“引用”有关。在JDK1.2之前，Java中的引用对象的定义很传统；如果reference类型的数据中存储的数值代表的是另一块内存的
起始地址，就称为这块内存代表着一个引用，这样定义很纯粹；

在JDK1.2之后，Java对引用的概念进行了区分：**强引用，软引用，弱引用，虚引用；**

#### 4.2.3.1 强引用
强引用就是程序代码之间普遍存在的。类似`Object o = new Object()`的存在，垃圾回收器永远都不会删除的对象；
#### 4.2.3.1 软引用
软引用是指用来描述一些还有用但是没有必要的对象。对于软引用关联着的对象，在系统将要发生的内存溢出异常之前，会将这些对象纳入回收范围内进行二次回收，防止内存溢出，如果这次回收还是没有足够的
内存空间，将抛出内存溢出的异常。JDK1.2之后，提供了`SoftReference`类来实现软引用；
#### 4.2.3.1 弱引用
弱引用是指用来描述那些非必要的对象的，但是他的强度比软应用更弱一些，被弱引用关联的对象，在GC发生之前，不管内存充不充足都会别垃圾处理器收集器回收掉；
JDK1.2之后，提供了`WeakReference`类来实现软引用；
#### 4.2.3.1 虚引用
虚引用也成为幽灵应用，它是一种最弱的应用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取一个真实的对象实例。为一个对象设置虚引用关联唯一目的
就是能够在这个对象被收集器回收时接受一个系统通知。JDK1.2之后，提供了`PhantomReference`类来实现软引用；


## 4.2 回收算法
我们都知道java对象是在堆上分配的（不考虑逃逸分析），通过垃圾回收器将不再使用的对象进行垃圾回收从而防止内存溢出。根据对象的不同生命周期将堆分成了两块年轻代和老年代，这样我们就可以根据每个
年代的特点选择合适的算法；
### 4.3.1 标记-复制算法
![标记复制算法](../resource/images/GC/标记复制算法.jpeg ':size=600x300')

标记复制算法，将内存分为了两半，一半存储对象，另一半空闲，进行回收时将存活对象打上标记，然后复制到另一半的内存中，将原来的内存进行回收；
**回收效率高，但因为内存分为了两半，浪费了一半的内存空间**

### 4.3.2 标记-清除算法
![标记清除算法](../resource/images/GC/标记清除算法.jpeg ':size=600x300')

标记清楚算法，回收时将内存中存活的对象打上GC标记，将未标记的内存行进行回收；**如果回收对象太多，效率不会太高，而且会产生大量不连续的空间碎片；**

### 4.3.2 标记-整理算法

![标记整理算法](../resource/images/GC/标记整理算法.jpeg ':size=600x300')

标记整理算法，回收时将存活的对象打上标记，虽然过程和标记-清除算法一样，但是后续回收不是直接回收对象，而是让对象向一端移动，然后清理掉边界以外的内存；

**新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上**

## 4.3 垃圾收集器

### 4.3.1 概述

如果说垃圾收集算法是方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器的实现并没有明确规定，因此许多厂商有着不同版本的虚拟机所提供垃圾收集实现
都有着很大的区别，并且都会提供参数配置供用户根据自己的应用特点和要求组合出各个年代的所使用的收集器；


![垃圾收集器分代图](../resource/images/GC/垃圾收集器分代图.jpg ':size=50%')

### 4.3.2 Serial 收集器
这款垃圾收集器可以说是年代久远的老牌收集器，可以看名字知道，这是一款单线程的垃圾收集器，**这里单线程的意义不仅仅只说明它只会使用一个CPU或者一条收集线程去完成垃圾回收，
最重要的是他会**`“Stop The Word”`，暂停整个世界，意思是发生`STW`会暂停整个JVM进程，专心收集垃圾，直到垃圾收集结束。这项工作是实际上是由虚拟机在后台自动发起的和自动完成
的操作，这就意味着，在用户不知情的情况下，突然就暂停所有用户线程，这让许多应用难以接受。如果回收工作越大量大，线程将锁死时间越长。

**下面是他的工作流程**

![Serial收集器执行过程图](../resource/images/GC/Serial收集器执行过程图.jpg ':size=60%')

对于`STW`带给用户不良体验也是情有可原，如果“你妈妈在打扫房间，你肯定老老实实在呆着，如果她一边打扫你一边丢垃圾，这还打扫得完？”。

从JDK1.3开始，直到现在，垃圾收集器一直都在迭代跟新，每一代都有着优秀的新能，`Serial收集器`也不是一无是处，他直到现在一直都是年轻代默认的垃圾收集器，它也有着优秀与其他
收集器的地方，**“简单高效”**对于限定单CPU的收集起来说，它跟注重垃圾的收集，没有任何其他线程的开销。

**Serial Old收集器：**是Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，
另一种用途是作为CMS收集器的后备方案。


### 4.3.3 ParNew 收集器
`ParNew收集器`其实就是`Serial收集器`的多线程版本，除了使用多线程进行垃圾收集器外，真个过程也会`STW`堵塞其他用户线程，他的回收策略、回收算法都与`Serial收集器`相同。

**下面是他的工作流程**

![ParNew收集器执行过程图](../resource/images/GC/ParNew收集器执行过程图.jpg ':size=60%')

除了`Serial收集器` 以外，目前只有它才能与CMS配合工作。

### 4.3.4 Parallel Scavenge 收集器

`Parallel Scavenge收集器`因为利用的多个CPU的原理，所以它更加专注吞吐量，如果不在乎`STW`，更专注吞吐量，这是个不错的选择；