


> 作者：ZlZ。
>
> **介绍:** 此篇幅将简述垃圾收集器底层原理，干货满满

## 4.1 概述
说起垃圾收集器，大部分人都把这项技术当作Java语言的伴生产物，实际上，GC的历史远远比Java久远，1960年诞生与MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的的语言。当ListP
还在胚胎的时候，人们就在思考GC需要完成的三个步骤
- 哪些内存对象需要回收？
- 什么时候回收？
- 如何回收？

经过半个世纪的发展，目前内存的动态与内存回收技术已经十分成熟，一起看起来都进入了“自动化”的时代，那为什么我们还需要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出，内存泄漏问题时
，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

## 4.2 回收算法
我们都知道java对象是在堆上分配的（不考虑逃逸分析），通过垃圾回收器将不再使用的对象进行垃圾回收从而防止内存溢出。根据对象的不同生命周期将堆分成了两块年轻代和老年代，这样我们就可以根据每个
年代的特点选择合适的算法；
### 4.2.1 标记-复制算法
![标记复制算法](../resource/images/GC/标记复制算法.jpeg ':size=600x300')

标记复制算法，将内存分为了两半，一半存储对象，另一半空闲，进行回收时将存活对象打上标记，然后复制到另一半的内存中，将原来的内存进行回收；
**回收效率高，但因为内存分为了两半，浪费了一半的内存空间**

### 4.2.2 标记-清除算法
![标记清除算法](../resource/images/GC/标记清除算法.jpeg ':size=600x300')

标记清楚算法，回收时将内存中存活的对象打上GC标记，然后将未标记的内存行进行回收；**如果回收对象太多，效率不会太高，而且会产生大量不连续的空间碎片；**

### 4.2.2 标记-整理算法

![标记整理算法](../resource/images/GC/标记整理算法.jpeg ':size=600x300')

标记整理算法，回收时将存活的对象打上标记，虽然过程和标记-清除算法一样，但是后续回收不是直接回收对象，而是让对象向一端移动，然后清理掉边界以外的内存；

**新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上**

## 4.3 垃圾收集器

