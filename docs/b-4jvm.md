

## 2.4 JVM内存模型

> 作者：小周吃了吗。
>
> **介绍:** 此篇幅将简述JVM底层结构以及调优知识

java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的"高墙"，墙外的人想进去，墙里边的人想出来。
### 2.4.1 概述

对于从事C++程序开发的开发人员来说，内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础的劳动人民--既拥有对象的所有权，又担负着每一个对象生命从开始到终结的维护责任。

对于java程序来说，在虚拟机自动管理内存机制下，不需要为每一个对象去编写delete/free代码，不容易出现内存泄露和内存溢出的问题，正因为如此，将权力交给虚拟机，一旦出现内存泄露和内存溢出的问题，如果不了解虚拟机，这将是非常麻烦的一件事情。本编 将对虚拟机展开由浅层次到深入的探索

### 运行时数据区域
java虚拟机将内存划分了不同区域，每个区域对应不同的用途

**JDK1.8：**

![jvm结构图](../resource/images/jvm/JVM内存模型.png)


#### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

#### Java 虚拟机栈

**与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，每开启一个线程就会分配一个栈空间，而每调用一个方法则会分配一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**

**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

- **局部变量表：** 顾名思义，存储每个方法的局部变量；
- **操作数栈：** 例如:此时方法代码有`a=1;b=2;c=a+b`，代码从上往下运行，**虚拟机会将常量1压入操作数栈中，然后赋值给变量a，变量b也是如此，在将常量1、2压入操作数栈计算得3，将3压入操作数栈，最后赋值给变量c；** 具体详情这里不再深入（详情见：***）
- **动态链接：** 
- **方法出口：** 

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

#### 本地方法栈

和虚拟机栈所发挥的作用非常相似，**他们之间区别不过只是虚拟机本地栈运行自己编写的java代码，而本地方法栈则是运行虚拟机中Native(其他语言，例C++)方法**
#### 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**
